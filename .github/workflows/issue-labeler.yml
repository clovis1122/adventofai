name: Issue Auto-Labeler with Goose

on:
  issues:
    types: [opened]

permissions:
  issues: write
  contents: read

jobs:
  label-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Create labels if they don't exist
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labelsToCreate = [
              { name: 'Urgent', color: 'D73A4A', description: 'Critical issues requiring immediate attention' },
              { name: 'Feature', color: '0E8A16', description: 'New feature requests or enhancements' },
              { name: 'Question', color: 'D876E3', description: 'Questions or requests for clarification' }
            ];
            
            for (const label of labelsToCreate) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
                console.log(`Created label: ${label.name}`);
              } catch (error) {
                if (error.status === 422) {
                  console.log(`Label ${label.name} already exists`);
                } else {
                  throw error;
                }
              }
            }

      - name: Install Goose CLI
        run: |
          mkdir -p /home/runner/.local/bin
          curl -fsSL https://github.com/block/goose/releases/download/stable/download_cli.sh \
            | CONFIGURE=false GOOSE_BIN_DIR=/home/runner/.local/bin bash
          echo "/home/runner/.local/bin" >> $GITHUB_PATH

      - name: Configure Goose
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          mkdir -p ~/.config/goose
          cat <<EOF > ~/.config/goose/config.yaml
          GOOSE_PROVIDER__OPENROUTER__API_KEY: ${OPENROUTER_API_KEY}
          GOOSE_MODEL: openrouter/anthropic/claude-3.5-sonnet
          keyring: false
          EOF

      - name: Analyze Issue with Goose
        id: analyze
        run: |
          cat > instructions.txt << 'EOF'
          Analyze the following GitHub issue and categorize it with one or more of these labels: Urgent, Feature, Question.

          Issue Title: ${{ github.event.issue.title }}
          Issue Body: ${{ github.event.issue.body }}

          Guidelines:
          - Urgent: Critical bugs, security issues, production problems, blockers
          - Feature: Feature requests, enhancements, new functionality
          - Question: Questions, help requests, clarification needed

          Respond with ONLY a JSON object in this exact format (no other text):
          {"labels": ["Label1", "Label2"], "reasoning": "Brief explanation"}
          EOF
          
          goose run --instructions instructions.txt | \
            sed -E 's/\x1B\[[0-9;]*[mK]//g' | \
            grep -v "logging to /home/runner/.config/goose/sessions/" | \
            grep -v "^starting session" | \
            grep -v "^Closing session" | \
            sed 's/[[:space:]]*$//' \
            > response.txt
          
          cat response.txt
          
          # Extract JSON from response
          if grep -o '{[^}]*"labels"[^}]*}' response.txt > analysis.json 2>/dev/null; then
            cat analysis.json
            echo "analysis=$(cat analysis.json)" >> $GITHUB_OUTPUT
          else
            echo '{"labels": ["Question"], "reasoning": "Could not parse AI response"}' > analysis.json
            echo "analysis=$(cat analysis.json)" >> $GITHUB_OUTPUT
          fi

      - name: Apply Labels and Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const analysisStr = `${{ steps.analyze.outputs.analysis }}`;
            let analysis;
            
            try {
              analysis = JSON.parse(analysisStr);
            } catch (error) {
              console.error('Failed to parse analysis:', error);
              analysis = { labels: ['Question'], reasoning: 'Failed to analyze issue' };
            }
            
            const labels = analysis.labels || ['Question'];
            const reasoning = analysis.reasoning || 'Automated analysis';
            
            // Apply labels to the issue
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                labels: labels
              });
              
              console.log(`Applied labels: ${labels.join(', ')}`);
            }
            
            // Post a comment with analysis
            const comment = `ðŸ¤– **AI-Powered Analysis (via Goose)**\n\n` +
              `This issue has been analyzed and labeled as: **${labels.join(', ')}**\n\n` +
              `**Reasoning:** ${reasoning}\n\n` +
              `If you believe this categorization is incorrect, please feel free to adjust the labels manually.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: comment
            });
